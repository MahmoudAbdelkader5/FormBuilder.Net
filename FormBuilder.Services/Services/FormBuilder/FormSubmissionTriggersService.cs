using FormBuilder.Core.IServices.FormBuilder;
using FormBuilder.Domian.Entitys.FormBuilder;
using FormBuilder.Domain.Interfaces.Services;
using FormBuilder.Services.Services.Email;
using FormBuilder.Application.DTOs.ApprovalWorkflow;
using FormBuilder.Core.DTOS.FormBuilder;
using formBuilder.Domian.Interfaces;
using FormBuilder.Domian.Entitys.FormBuilder;
using Microsoft.Extensions.Logging;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace FormBuilder.Services.Services.FormBuilder
{
    /// <summary>
    /// Service for handling event-based triggers in form submission workflow
    /// All triggers execute immediately after database state changes within the same transaction
    /// </summary>
    public class FormSubmissionTriggersService : IFormSubmissionTriggersService
    {
        private readonly IunitOfwork _unitOfWork;
        private readonly IDocumentApprovalHistoryService _historyService;
        private readonly EmailNotificationService _emailNotificationService;
        private readonly ISapDynamicIntegrationService _sapDynamicIntegrationService;
        private readonly ILogger<FormSubmissionTriggersService> _logger;
        private readonly IServiceScopeFactory _scopeFactory;

        public FormSubmissionTriggersService(
            IunitOfwork unitOfWork,
            IDocumentApprovalHistoryService historyService,
            EmailNotificationService emailNotificationService,
            ISapDynamicIntegrationService sapDynamicIntegrationService,
            ILogger<FormSubmissionTriggersService> logger,
            IServiceScopeFactory scopeFactory)
        {
            _unitOfWork = unitOfWork;
            _historyService = historyService;
            _emailNotificationService = emailNotificationService;
            _sapDynamicIntegrationService = sapDynamicIntegrationService;
            _logger = logger;
            _scopeFactory = scopeFactory;
        }

        /// <summary>
        /// Executes workflow runtime work inside an async scope to avoid scoped-lifetime leaks.
        /// </summary>
        private async Task<T?> ExecuteWithWorkflowRuntimeServiceAsync<T>(
            Func<IApprovalWorkflowRuntimeService, Task<T>> action) where T : class
        {
            if (_scopeFactory == null)
                return null;

            try
            {
                await using var scope = _scopeFactory.CreateAsyncScope();
                var workflowRuntimeService = scope.ServiceProvider.GetService<IApprovalWorkflowRuntimeService>();
                if (workflowRuntimeService == null)
                    return null;

                return await action(workflowRuntimeService);
            }
            catch (Exception ex)
            {
                _logger?.LogWarning(ex, "Failed to resolve or execute IApprovalWorkflowRuntimeService");
                return null;
            }
        }

        /// <summary>
        /// FormSubmitted Trigger: Executes when a new submission is created with Status = "Submitted"
        /// Trigger Condition: FORM_SUBMISSIONS.Status = "Submitted" (new record inserted or status changed to Submitted)
        /// Actions:
        /// 1. Generate Document Number (already handled by numbering engine on Submit/Approval based on series.GenerateOn)
        /// 2. Initialize approval workflow (handled by ActivateStageForSubmissionAsync which is called from SubmitAsync)
        /// 3. Insert history record
        /// 4. Ensure ALERT_RULES entry exists (auto-create if missing with IsActive = false)
        /// 5. Send submission confirmation email (only if ALERT_RULES allows it)
        /// 6. Create internal notification
        /// </summary>
        public async Task ExecuteFormSubmittedTriggerAsync(FORM_SUBMISSIONS submission)
        {
            try
            {
                _logger?.LogInformation("Executing FormSubmitted trigger for submission {SubmissionId}", submission.Id);

                // Action 1: Generate Document Number
                // Document number is generated by the numbering engine at controlled lifecycle events
                // (Submit or final Approval) based on series.GenerateOn.
                // Trigger only verifies presence and does not regenerate.
                if (string.IsNullOrEmpty(submission.DocumentNumber))
                {
                    _logger?.LogWarning("Document number is missing for submission {SubmissionId}. Series numbering may be configured for Approval and not reached yet.", submission.Id);
                }

                // Action 2: Initialize approval workflow
                // This is handled by ActivateStageForSubmissionAsync which is called from SubmitAsync
                // The workflow initialization happens before this trigger is called
                // So we skip this action here

                // Action 3: Insert history record
                // Create initial submission history record
                // IMPORTANT:
                // DOCUMENT_APPROVAL_HISTORY.StageId has an FK to APPROVAL_STAGES, so it must be a valid stage ID.
                // When SubmitAsync calls this trigger, StageId may not be assigned yet (activation happens right after submit).
                // Therefore, only persist history when StageId is present and valid (>0).
                if (submission.StageId.HasValue && submission.StageId.Value > 0)
                {
                    var historyDto = new DocumentApprovalHistoryCreateDto
                    {
                        SubmissionId = submission.Id,
                        StageId = submission.StageId.Value,
                        ActionType = "Submitted",
                        ActionByUserId = submission.SubmittedByUserId ?? "public-user",
                        Comments = "Form submitted successfully"
                    };

                    await _historyService.CreateAsync(historyDto);
                }
                else
                {
                    _logger?.LogInformation(
                        "Skipping submission history insert for submission {SubmissionId} because StageId is not assigned yet.",
                        submission.Id);
                }

                // Action 4: Send submission confirmation email (only if ALERT_RULES allows it)
                // Get recipients from ALERT_RULES, default to SubmittedByUserId if no rule specifies recipients
                if (IsPublicUserSubmission(submission))
                {
                    _logger?.LogInformation("Public-user submission detected. Skipping FormSubmitted email for submission {SubmissionId}", submission.Id);
                }
                else
                {
                var recipients = await GetEmailRecipientsAsync(submission.DocumentTypeId, "FormSubmitted", submission.SubmittedByUserId);
                if (recipients.Any())
                {
                    var submissionIdCopy = submission.Id;
                    var recipientsCopy = recipients.ToList();
                    
                    _ = Task.Run(async () =>
                    {
                        try
                        {
                            await using var scope = _scopeFactory.CreateAsyncScope();
                            var emailService = scope.ServiceProvider.GetRequiredService<EmailNotificationService>();
                            await emailService.SendSubmissionConfirmationToRecipientsAsync(submissionIdCopy, recipientsCopy);
                        }
                        catch (Exception ex)
                        {
                            _logger?.LogError(ex, "Failed to send submission confirmation email for submission {SubmissionId}", submissionIdCopy);
                        }
                    });
                }
                else
                {
                    _logger?.LogInformation("Email sending skipped for submission {SubmissionId} based on ALERT_RULES configuration", submission.Id);
                    }
                }

                // Action 6: Create internal notification
                // TODO: Implement notification service when available
                // For now, we log it
                _logger?.LogInformation("Internal notification should be created for submission {SubmissionId}", submission.Id);

                // Action 7: Execute CopyToDocument actions (OnFormSubmitted event)
                await ExecuteCopyToDocumentActionsAsync(submission.Id, "OnFormSubmitted", submission.SubmittedByUserId);

                // Action 8: Execute SAP Service Layer integration (if enabled and execution mode = OnSubmit)
                await _sapDynamicIntegrationService.ExecuteForSubmissionAsync(submission.Id, "FormSubmitted");

                _logger?.LogInformation("FormSubmitted trigger completed for submission {SubmissionId}", submission.Id);
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "Error executing FormSubmitted trigger for submission {SubmissionId}", submission.Id);
                // Don't throw - trigger failures should not block the main workflow
            }
        }

        /// <summary>
        /// ApprovalRequired Trigger: Executes when StageId is assigned/changed and Status = "Pending" or "Submitted"
        /// Trigger Condition: StageId assigned or changed AND Status = "Pending" or "Submitted"
        /// Actions:
        /// 1. Resolve approvers (roles / users)
        /// 2. Apply delegation rules (replaces approver if delegation exists)
        /// 3. Send approval request emails
        /// 4. Create approver inbox notifications
        /// </summary>
        public async Task ExecuteApprovalRequiredTriggerAsync(FORM_SUBMISSIONS submission, int stageId)
        {
            try
            {
                _logger?.LogInformation("Executing ApprovalRequired trigger for submission {SubmissionId}, stage {StageId}", submission.Id, stageId);

                // Verify submission status is appropriate for approval
                if (submission.Status != "Submitted" && submission.Status != "Pending")
                {
                    _logger?.LogWarning("Submission {SubmissionId} status is {Status}, not Submitted or Pending. Skipping ApprovalRequired trigger.", submission.Id, submission.Status);
                    return;
                }

                // Action 1: Resolve approvers (roles / users)
                // IMPORTANT: Even if we can't resolve approvers (or stage has no assignees),
                // we should still allow notifications/emails to be sent based on ALERT_RULES.TargetUserId/TargetRoleId.
                var approverUserIds = new List<string>();

                var approversResult = await ExecuteWithWorkflowRuntimeServiceAsync(
                    runtime => runtime.ResolveApproversForStageAsync(stageId));
                if (approversResult == null)
                {
                    _logger?.LogWarning("Failed to resolve IApprovalWorkflowRuntimeService for stage {StageId}. Will rely on ALERT_RULES recipients only.", stageId);
                }
                else
                {
                    if (approversResult.StatusCode != 200)
                    {
                        _logger?.LogWarning("Failed to resolve approvers for stage {StageId}: {Message}. Will rely on ALERT_RULES recipients only.",
                            stageId, approversResult.Message);
                    }
                    else
                    {
                        var resolvedApprovers = approversResult.Data as ResolvedApproversDto;
                        if (resolvedApprovers?.UserIds != null && resolvedApprovers.UserIds.Any())
                        {
                            approverUserIds = resolvedApprovers.UserIds.ToList();
                        }
                        else
                        {
                            _logger?.LogWarning("No approvers resolved for stage {StageId}. Will rely on ALERT_RULES recipients only.", stageId);
                        }
                    }
                }

                // Action 2: Apply delegation rules
                // Delegation is already applied during approver resolution in ResolveApproversForStageAsync
                // The ResolveApproversForStageAsync method checks for delegations and replaces approvers accordingly
                // Delegation priority: Document -> Workflow -> Global
                _logger?.LogInformation("Delegation rules applied during approver resolution for stage {StageId}", stageId);

                // Action 3: Send approval request emails (only if ALERT_RULES allows it)
                // Get recipients from ALERT_RULES, if no rule specifies recipients, use approvers from stage
                var alertRecipients = await GetEmailRecipientsAsync(submission.DocumentTypeId, "ApprovalRequired");
                var finalRecipients = alertRecipients.Any() ? alertRecipients : approverUserIds.ToList();
                
                if (finalRecipients.Any())
                {
                    // Action: Create internal notifications for approvers (only if ALERT_RULES allows Internal/Both)
                    await CreateInternalNotificationsForApproversAsync(
                        documentTypeId: submission.DocumentTypeId,
                        triggerType: "ApprovalRequired",
                        defaultRecipients: finalRecipients,
                        submissionId: submission.Id,
                        cancellationToken: CancellationToken.None);

                    if (IsPublicUserSubmission(submission))
                    {
                        _logger?.LogInformation("Public-user submission detected. Skipping ApprovalRequired email for submission {SubmissionId}", submission.Id);
                    }
                    else
                    {
                    var submissionIdCopy = submission.Id;
                    var stageIdCopy = stageId;
                    var recipientsCopy = finalRecipients.ToList();
                    
                    _ = Task.Run(async () =>
                    {
                        try
                        {
                            await using var scope = _scopeFactory.CreateAsyncScope();
                            var emailService = scope.ServiceProvider.GetRequiredService<EmailNotificationService>();
                            await emailService.SendApprovalRequiredAsync(
                                submissionIdCopy, 
                                stageIdCopy, 
                                recipientsCopy);
                        }
                        catch (Exception ex)
                        {
                            _logger?.LogError(ex, "Failed to send approval required emails for submission {SubmissionId}, stage {StageId}", submissionIdCopy, stageIdCopy);
                        }
                    });
                    }
                }
                else
                {
                    _logger?.LogInformation("Email sending skipped for submission {SubmissionId}, stage {StageId} - no recipients found", submission.Id, stageId);
                }

                // Action 4: Create approver inbox notifications
                // TODO: Implement notification service when available
                // For now, we log it
                _logger?.LogInformation("Approver inbox notifications should be created for submission {SubmissionId}, stage {StageId}, approvers: {Approvers}", 
                    submission.Id, stageId, string.Join(", ", approverUserIds));

                // Execute SAP integration for stage-based rule (if configured: OnSpecificWorkflowStage)
                await _sapDynamicIntegrationService.ExecuteForSubmissionAsync(submission.Id, "ApprovalRequired", stageId);

                _logger?.LogInformation("ApprovalRequired trigger completed for submission {SubmissionId}, stage {StageId}", submission.Id, stageId);
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "Error executing ApprovalRequired trigger for submission {SubmissionId}, stage {StageId}", submission.Id, stageId);
                // Don't throw - trigger failures should not block the main workflow
            }
        }

        /// <summary>
        /// ApprovalApproved Trigger: Executes when ActionType = "Approved" in approval history
        /// Trigger Condition: DOCUMENT_APPROVAL_HISTORY.ActionType = "Approved"
        /// Actions:
        /// 1. Log approval history (already done in ProcessApprovalActionAsync before trigger is called)
        /// 2. Check if stage is final (already handled in ProcessApprovalActionAsync)
        /// 3. Move to next stage or complete document (already handled in ProcessApprovalActionAsync)
        /// 4. Send approval notification email
        /// 5. If moved to next stage, trigger ApprovalRequired for the new stage
        /// </summary>
        public async Task ExecuteApprovalApprovedTriggerAsync(DOCUMENT_APPROVAL_HISTORY history, FORM_SUBMISSIONS submission)
        {
            try
            {
                _logger?.LogInformation("Executing ApprovalApproved trigger for submission {SubmissionId}, history {HistoryId}", submission.Id, history.Id);

                // Action 1: Log approval history
                // Already done in ProcessApprovalActionAsync before calling this trigger
                // History record is created and saved to database before trigger execution

                // Action 2: Check if stage is final
                // Already handled in ProcessApprovalActionAsync
                // If final stage: Status = "Approved", StageId = null
                // If not final: Status = "Submitted", StageId = next stage ID

                // Action 3: Move to next stage or complete document
                // Already handled in ProcessApprovalActionAsync
                // Status and StageId are updated in ProcessApprovalActionAsync before trigger is called

                // Reload submission to get latest state after ProcessApprovalActionAsync updates
                var updatedSubmission = await _unitOfWork.FormSubmissionsRepository.GetByIdAsync(submission.Id);
                if (updatedSubmission == null)
                {
                    _logger?.LogWarning("Submission {SubmissionId} not found after approval action", submission.Id);
                    return;
                }

                // Execute SAP integration for final approval mode (if configured: OnFinalApproval)
                await _sapDynamicIntegrationService.ExecuteForSubmissionAsync(updatedSubmission.Id, "ApprovalApproved");

                // ✅ Internal Notifications (controlled by ALERT_RULES.NotificationType = Internal/Both)
                // Default recipients: SubmittedByUserId (if rule has no targets)
                await CreateInternalNotificationsForTriggerAsync(
                    documentTypeId: updatedSubmission.DocumentTypeId,
                    triggerType: "ApprovalApproved",
                    defaultRecipients: string.IsNullOrWhiteSpace(updatedSubmission.SubmittedByUserId)
                        ? Array.Empty<string>()
                        : new[] { updatedSubmission.SubmittedByUserId },
                    submissionId: updatedSubmission.Id,
                    title: $"Submission Approved - {updatedSubmission.DocumentNumber}",
                    message: "Your submission has been approved.",
                    severityType: "Success",
                    cancellationToken: CancellationToken.None);

                // Action 4: Send approval notification email (only if ALERT_RULES allows it)
                // Get recipients from ALERT_RULES, default to SubmittedByUserId if no rule specifies recipients
                _logger?.LogInformation("Getting email recipients for ApprovalApproved. DocumentTypeId: {DocumentTypeId}, SubmittedByUserId: {SubmittedByUserId}",
                    updatedSubmission.DocumentTypeId, updatedSubmission.SubmittedByUserId);
                
                if (IsPublicUserSubmission(updatedSubmission))
                {
                    _logger?.LogInformation("Public-user submission detected. Skipping ApprovalApproved email for submission {SubmissionId}", updatedSubmission.Id);
                }
                else
                {
                var recipients = await GetEmailRecipientsAsync(updatedSubmission.DocumentTypeId, "ApprovalApproved", updatedSubmission.SubmittedByUserId);
                
                _logger?.LogInformation("Resolved {Count} recipients for ApprovalApproved: {Recipients}",
                    recipients.Count, string.Join(", ", recipients));
                
                if (recipients.Any())
                {
                    var submissionIdCopy = updatedSubmission.Id;
                    var actionByUserIdCopy = history.ActionByUserId;
                    var commentsCopy = history.Comments;
                    var recipientsCopy = recipients.ToList();
                    
                    _logger?.LogInformation("Sending approval notification email for submission {SubmissionId} to {Count} recipients: {Recipients}",
                        submissionIdCopy, recipientsCopy.Count, string.Join(", ", recipientsCopy));
                    
                    _ = Task.Run(async () =>
                    {
                        try
                        {
                            await using var scope = _scopeFactory.CreateAsyncScope();
                            var emailService = scope.ServiceProvider.GetRequiredService<EmailNotificationService>();
                            await emailService.SendApprovalResultToRecipientsAsync(
                                submissionIdCopy, 
                                "Approved", 
                                actionByUserIdCopy, 
                                commentsCopy,
                                recipientsCopy);
                            
                            _logger?.LogInformation("Approval notification email sent successfully for submission {SubmissionId}", submissionIdCopy);
                        }
                        catch (Exception ex)
                        {
                            _logger?.LogError(ex, "Failed to send approval notification email for submission {SubmissionId}. Error: {ErrorMessage}. StackTrace: {StackTrace}",
                                submissionIdCopy, ex.Message, ex.StackTrace);
                        }
                    });
                }
                else
                {
                    _logger?.LogWarning("Email sending skipped for submission {SubmissionId} - no recipients resolved. DocumentTypeId: {DocumentTypeId}, SubmittedByUserId: {SubmittedByUserId}",
                        updatedSubmission.Id, updatedSubmission.DocumentTypeId, updatedSubmission.SubmittedByUserId);
                    }
                }

                // Action 5: If moved to next stage, trigger ApprovalRequired for the new stage
                if (updatedSubmission.Status == "Submitted" && updatedSubmission.StageId.HasValue && updatedSubmission.StageId.Value > 0)
                {
                    _logger?.LogInformation("Approval approved, moving to next stage {StageId} for submission {SubmissionId}", 
                        updatedSubmission.StageId.Value, updatedSubmission.Id);
                    await ExecuteApprovalRequiredTriggerAsync(updatedSubmission, updatedSubmission.StageId.Value);
                }
                else if (updatedSubmission.Status == "Approved")
                {
                    _logger?.LogInformation("Approval approved, document completed for submission {SubmissionId}", updatedSubmission.Id);
                    
                    // Execute CopyToDocument actions (OnApprovalCompleted / OnDocumentApproved event)
                    await ExecuteCopyToDocumentActionsAsync(updatedSubmission.Id, "OnApprovalCompleted", history.ActionByUserId);
                }

                _logger?.LogInformation("ApprovalApproved trigger completed for submission {SubmissionId}", updatedSubmission.Id);
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "Error executing ApprovalApproved trigger for submission {SubmissionId}", submission.Id);
                // Don't throw - trigger failures should not block the main workflow
            }
        }

        /// <summary>
        /// ApprovalRejected Trigger: Executes when ActionType = "Rejected" in approval history
        /// Trigger Condition: DOCUMENT_APPROVAL_HISTORY.ActionType = "Rejected"
        /// Actions:
        /// 1. Update document status to Rejected (already done in ProcessApprovalActionAsync)
        /// 2. Lock document (enforced by business rules in UpdateAsync and SaveFormSubmissionDataAsync)
        /// 3. Send rejection email
        /// </summary>
        public async Task ExecuteApprovalRejectedTriggerAsync(DOCUMENT_APPROVAL_HISTORY history, FORM_SUBMISSIONS submission)
        {
            try
            {
                _logger?.LogInformation("Executing ApprovalRejected trigger for submission {SubmissionId}, history {HistoryId}", submission.Id, history.Id);

                // Reload submission to get latest state after ProcessApprovalActionAsync updates
                var updatedSubmission = await _unitOfWork.FormSubmissionsRepository.GetByIdAsync(submission.Id);
                if (updatedSubmission == null)
                {
                    _logger?.LogWarning("Submission {SubmissionId} not found after rejection action", submission.Id);
                    return;
                }

                // ✅ Internal Notifications (controlled by ALERT_RULES.NotificationType = Internal/Both)
                // Default recipients: SubmittedByUserId (if rule has no targets)
                await CreateInternalNotificationsForTriggerAsync(
                    documentTypeId: updatedSubmission.DocumentTypeId,
                    triggerType: "ApprovalRejected",
                    defaultRecipients: string.IsNullOrWhiteSpace(updatedSubmission.SubmittedByUserId)
                        ? Array.Empty<string>()
                        : new[] { updatedSubmission.SubmittedByUserId },
                    submissionId: updatedSubmission.Id,
                    title: $"Submission Rejected - {updatedSubmission.DocumentNumber}",
                    message: "Your submission has been rejected.",
                    severityType: "Error",
                    cancellationToken: CancellationToken.None);

                // Action 1: Update document status to Rejected
                // Already done in ProcessApprovalActionAsync
                // Status is set to "Rejected" in ProcessApprovalActionAsync before trigger is called
                if (updatedSubmission.Status != "Rejected")
                {
                    _logger?.LogWarning("Submission {SubmissionId} status is {Status}, expected Rejected", updatedSubmission.Id, updatedSubmission.Status);
                }

                // Action 2: Lock document
                // Document locking is enforced by business rules in:
                // - UpdateAsync method: checks if Status == "Rejected" and returns 403
                // - SaveFormSubmissionDataAsync method: checks if Status == "Rejected" and returns 403
                // The document is effectively locked by these business rules
                _logger?.LogInformation("Document {SubmissionId} is locked due to rejection. Status: {Status}", 
                    updatedSubmission.Id, updatedSubmission.Status);

                // Action 3: Send rejection email (only if ALERT_RULES allows it)
                // Get recipients from ALERT_RULES, default to SubmittedByUserId if no rule specifies recipients
                _logger?.LogInformation("Getting email recipients for ApprovalRejected. DocumentTypeId: {DocumentTypeId}, SubmittedByUserId: {SubmittedByUserId}",
                    updatedSubmission.DocumentTypeId, updatedSubmission.SubmittedByUserId);
                
                if (IsPublicUserSubmission(updatedSubmission))
                {
                    _logger?.LogInformation("Public-user submission detected. Skipping ApprovalRejected email for submission {SubmissionId}", updatedSubmission.Id);
                }
                else
                {
                var recipients = await GetEmailRecipientsAsync(updatedSubmission.DocumentTypeId, "ApprovalRejected", updatedSubmission.SubmittedByUserId);
                
                _logger?.LogInformation("Resolved {Count} recipients for ApprovalRejected: {Recipients}",
                    recipients.Count, string.Join(", ", recipients));
                
                if (recipients.Any())
                {
                    var submissionIdCopy = updatedSubmission.Id;
                    var actionByUserIdCopy = history.ActionByUserId;
                    var commentsCopy = history.Comments;
                    var recipientsCopy = recipients.ToList();
                    
                    _logger?.LogInformation("Sending rejection notification email for submission {SubmissionId} to {Count} recipients: {Recipients}",
                        submissionIdCopy, recipientsCopy.Count, string.Join(", ", recipientsCopy));
                    
                    _ = Task.Run(async () =>
                    {
                        try
                        {
                            await using var scope = _scopeFactory.CreateAsyncScope();
                            var emailService = scope.ServiceProvider.GetRequiredService<EmailNotificationService>();
                            await emailService.SendApprovalResultToRecipientsAsync(
                                submissionIdCopy, 
                                "Rejected", 
                                actionByUserIdCopy, 
                                commentsCopy,
                                recipientsCopy);
                            
                            _logger?.LogInformation("Rejection notification email sent successfully for submission {SubmissionId}", submissionIdCopy);
                        }
                        catch (Exception ex)
                        {
                            _logger?.LogError(ex, "Failed to send rejection notification email for submission {SubmissionId}. Error: {ErrorMessage}. StackTrace: {StackTrace}",
                                submissionIdCopy, ex.Message, ex.StackTrace);
                        }
                    });
                }
                else
                {
                    _logger?.LogWarning("Email sending skipped for submission {SubmissionId} - no recipients resolved. DocumentTypeId: {DocumentTypeId}, SubmittedByUserId: {SubmittedByUserId}",
                        updatedSubmission.Id, updatedSubmission.DocumentTypeId, updatedSubmission.SubmittedByUserId);
                    }
                }

                _logger?.LogInformation("ApprovalRejected trigger completed for submission {SubmissionId}", updatedSubmission.Id);
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "Error executing ApprovalRejected trigger for submission {SubmissionId}", submission.Id);
                // Don't throw - trigger failures should not block the main workflow
            }
        }

        /// <summary>
        /// ApprovalReturned Trigger: Executes when ActionType = "Returned" in approval history
        /// Trigger Condition: DOCUMENT_APPROVAL_HISTORY.ActionType = "Returned"
        /// Actions:
        /// 1. Update status to Returned or Draft (already done in ProcessApprovalActionAsync)
        /// 2. Unlock form for editing (enforced by business rules - Draft/Returned status allows editing)
        /// 3. Send return email
        /// </summary>
        public async Task ExecuteApprovalReturnedTriggerAsync(DOCUMENT_APPROVAL_HISTORY history, FORM_SUBMISSIONS submission)
        {
            try
            {
                _logger?.LogInformation("Executing ApprovalReturned trigger for submission {SubmissionId}, history {HistoryId}", submission.Id, history.Id);

                // Reload submission to get latest state after ProcessApprovalActionAsync updates
                var updatedSubmission = await _unitOfWork.FormSubmissionsRepository.GetByIdAsync(submission.Id);
                if (updatedSubmission == null)
                {
                    _logger?.LogWarning("Submission {SubmissionId} not found after return action", submission.Id);
                    return;
                }

                // Action 1: Update status to Returned or Draft
                // Already done in ProcessApprovalActionAsync
                // Status is set to "Returned" or "Draft" in ProcessApprovalActionAsync before trigger is called
                // If returned to previous stage: Status = "Submitted", StageId = previous stage ID
                // If returned to beginning: Status = "Draft", StageId = null
                _logger?.LogInformation("Submission {SubmissionId} status updated to {Status} due to return", 
                    updatedSubmission.Id, updatedSubmission.Status);

                // Action 2: Unlock form for editing
                // When status is "Returned", "Draft", or "Submitted" (if not rejected/approved), the document is unlocked
                // This is enforced in UpdateAsync and SaveFormSubmissionDataAsync methods:
                // - They check if Status == "Rejected" or "Approved" and block editing
                // - For other statuses (Draft, Returned, Submitted), editing is allowed
                _logger?.LogInformation("Document {SubmissionId} is unlocked for editing due to return. Status: {Status}", 
                    updatedSubmission.Id, updatedSubmission.Status);

                // If returned to a previous stage, trigger ApprovalRequired for that stage
                if (updatedSubmission.Status == "Submitted" && updatedSubmission.StageId.HasValue && updatedSubmission.StageId.Value > 0)
                {
                    _logger?.LogInformation("Document returned to previous stage {StageId} for submission {SubmissionId}", 
                        updatedSubmission.StageId.Value, updatedSubmission.Id);
                    await ExecuteApprovalRequiredTriggerAsync(updatedSubmission, updatedSubmission.StageId.Value);
                }

                // Action 3: Send return email (only if ALERT_RULES allows it)
                // Get recipients from ALERT_RULES, default to SubmittedByUserId if no rule specifies recipients
                if (IsPublicUserSubmission(updatedSubmission))
                {
                    _logger?.LogInformation("Public-user submission detected. Skipping ApprovalReturned email for submission {SubmissionId}", updatedSubmission.Id);
                }
                else
                {
                var recipients = await GetEmailRecipientsAsync(updatedSubmission.DocumentTypeId, "ApprovalReturned", updatedSubmission.SubmittedByUserId);
                if (recipients.Any())
                {
                    var submissionIdCopy = updatedSubmission.Id;
                    var actionByUserIdCopy = history.ActionByUserId;
                    var commentsCopy = history.Comments;
                    var recipientsCopy = recipients.ToList();
                    
                    _ = Task.Run(async () =>
                    {
                        try
                        {
                            await using var scope = _scopeFactory.CreateAsyncScope();
                            var emailService = scope.ServiceProvider.GetRequiredService<EmailNotificationService>();
                            await emailService.SendApprovalResultToRecipientsAsync(
                                submissionIdCopy, 
                                "Returned", 
                                actionByUserIdCopy, 
                                commentsCopy,
                                recipientsCopy);
                        }
                        catch (Exception ex)
                        {
                            _logger?.LogError(ex, "Failed to send return notification email for submission {SubmissionId}", submissionIdCopy);
                        }
                    });
                }
                else
                {
                    _logger?.LogInformation("Email sending skipped for submission {SubmissionId} based on ALERT_RULES configuration", updatedSubmission.Id);
                    }
                }

                _logger?.LogInformation("ApprovalReturned trigger completed for submission {SubmissionId}", updatedSubmission.Id);
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "Error executing ApprovalReturned trigger for submission {SubmissionId}", submission.Id);
                // Don't throw - trigger failures should not block the main workflow
            }
        }

        /// <summary>
        /// Checks ALERT_RULES table to determine if email should be sent and returns list of recipient user IDs
        /// If no active rule exists, defaults to defaultUserId (e.g., SubmittedByUserId) to ensure email is sent
        /// Uses TargetUserId and TargetRoleId from ALERT_RULES to determine recipients
        /// </summary>
        private async Task<List<string>> GetEmailRecipientsAsync(int documentTypeId, string triggerType, string? defaultUserId = null)
        {
            try
            {
                _logger?.LogInformation("Checking ALERT_RULES for DocumentTypeId {DocumentTypeId}, TriggerType {TriggerType}, DefaultUserId {DefaultUserId}",
                    documentTypeId, triggerType, defaultUserId ?? "null");

                // If the submission is made by public-user, do not send any email
                // (skip all triggers to avoid sending to alert-rule recipients)
                if (string.Equals(defaultUserId, "public-user", StringComparison.OrdinalIgnoreCase))
                {
                    _logger?.LogInformation(
                        "Public user submission detected (user: {DefaultUserId}). Skipping email for trigger {TriggerType}.",
                        defaultUserId, triggerType);
                    return new List<string>();
                }

                // Check if there's an active ALERT_RULE for this document type and trigger type
                var alertRules = await _unitOfWork.AppDbContext
                    .Set<ALERT_RULES>()
                    .Where(ar =>
                        ar.DocumentTypeId == documentTypeId &&
                        ar.TriggerType == triggerType &&
                        (ar.NotificationType == "Email" || ar.NotificationType == "Both") &&
                        ar.IsActive &&
                        !ar.IsDeleted)
                    .ToListAsync();

                _logger?.LogInformation("Found {Count} active ALERT_RULE(s) for DocumentTypeId {DocumentTypeId}, TriggerType {TriggerType}",
                    alertRules.Count, documentTypeId, triggerType);

                var recipients = new HashSet<string>();

                // If no active rule exists, use defaultUserId (e.g., SubmittedByUserId) to ensure email is sent
                if (!alertRules.Any())
                {
                    if (!string.IsNullOrWhiteSpace(defaultUserId))
                    {
                        recipients.Add(defaultUserId);
                        _logger?.LogInformation("No active ALERT_RULE found for DocumentTypeId {DocumentTypeId}, TriggerType {TriggerType}. Using default user {DefaultUserId}.",
                            documentTypeId, triggerType, defaultUserId);
                    }
                    else
                    {
                        _logger?.LogWarning("No active ALERT_RULE found and no defaultUserId provided for DocumentTypeId {DocumentTypeId}, TriggerType {TriggerType}. Email will not be sent.",
                            documentTypeId, triggerType);
                    }
                    return recipients.ToList();
                }

                // Process each active alert rule
                foreach (var rule in alertRules)
                {
                    _logger?.LogInformation("Processing ALERT_RULE {RuleId}: TargetUserId={TargetUserId}, TargetRoleId={TargetRoleId}",
                        rule.Id, rule.TargetUserId ?? "null", rule.TargetRoleId ?? "null");

                    // Priority 1: TargetUserId - specific user
                    if (!string.IsNullOrWhiteSpace(rule.TargetUserId))
                    {
                        var userIds = rule.TargetUserId.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries)
                            .Select(u => u.Trim())
                            .Where(u => !string.IsNullOrWhiteSpace(u))
                            .ToList();
                        
                        foreach (var userId in userIds)
                        {
                            recipients.Add(userId);
                        }
                        
                        _logger?.LogInformation("Added {Count} users from TargetUserId in rule {RuleId}: {UserIds}", 
                            userIds.Count, rule.Id, string.Join(", ", userIds));
                    }

                    // Priority 2: TargetRoleId - users in role
                    if (!string.IsNullOrWhiteSpace(rule.TargetRoleId))
                    {
                        var roleIds = rule.TargetRoleId.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries)
                            .Select(r => r.Trim())
                            .Where(r => !string.IsNullOrWhiteSpace(r))
                            .ToList();

                        if (roleIds.Any())
                        {
                            var usersFromRoles = await ExecuteWithWorkflowRuntimeServiceAsync(
                                    runtime => runtime.ResolveUsersFromRolesAsync(roleIds))
                                ?? new List<string>();
                            foreach (var userId in usersFromRoles)
                            {
                                if (!string.IsNullOrWhiteSpace(userId))
                                {
                                    recipients.Add(userId);
                                }
                            }
                            
                            _logger?.LogInformation("Added {Count} users from TargetRoleId in rule {RuleId}: {RoleIds}", 
                                usersFromRoles.Count, rule.Id, string.Join(", ", roleIds));
                        }
                    }

                    // Priority 3: If neither TargetUserId nor TargetRoleId is specified, use default user (e.g., SubmittedByUserId)
                    if (string.IsNullOrWhiteSpace(rule.TargetUserId) && string.IsNullOrWhiteSpace(rule.TargetRoleId))
                    {
                        if (!string.IsNullOrWhiteSpace(defaultUserId))
                        {
                            recipients.Add(defaultUserId);
                            _logger?.LogInformation("Rule {RuleId} has no TargetUserId or TargetRoleId. Using default user {DefaultUserId}.", 
                                rule.Id, defaultUserId);
                        }
                        else
                        {
                            _logger?.LogWarning("Rule {RuleId} has no TargetUserId, TargetRoleId, or defaultUserId. No recipients added.", rule.Id);
                        }
                    }
                }

                if (recipients.Any())
                {
                    _logger?.LogInformation("ALERT_RULES resolved {Count} recipient(s) for DocumentTypeId {DocumentTypeId}, TriggerType {TriggerType}: {Recipients}", 
                        recipients.Count, documentTypeId, triggerType, string.Join(", ", recipients));
                }
                else
                {
                    _logger?.LogWarning("ALERT_RULES found but no recipients resolved for DocumentTypeId {DocumentTypeId}, TriggerType {TriggerType}. " +
                        "Checking if defaultUserId should be used: {DefaultUserId}",
                        documentTypeId, triggerType, defaultUserId ?? "null");
                    
                    // Fallback: if no recipients found from rules but defaultUserId exists, use it
                    if (!string.IsNullOrWhiteSpace(defaultUserId))
                    {
                        recipients.Add(defaultUserId);
                        _logger?.LogInformation("Using fallback defaultUserId {DefaultUserId} as no recipients were resolved from ALERT_RULES.", defaultUserId);
                    }
                }

                return recipients.ToList();
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "Error checking ALERT_RULES for DocumentTypeId {DocumentTypeId}, TriggerType {TriggerType}. " +
                    "Attempting to use defaultUserId: {DefaultUserId}",
                    documentTypeId, triggerType, defaultUserId ?? "null");
                
                // On error, try to use defaultUserId if available
                if (!string.IsNullOrWhiteSpace(defaultUserId))
                {
                    _logger?.LogInformation("Using defaultUserId {DefaultUserId} due to error in ALERT_RULES check.", defaultUserId);
                    return new List<string> { defaultUserId };
                }
                
                // If no defaultUserId, return empty list
                return new List<string>();
            }
        }

        /// <summary>
        /// Checks ALERT_RULES table to determine if email should be sent for a specific trigger type
        /// Returns true if there's an active ALERT_RULE with NotificationType = "Email" for the trigger type
        /// Returns false if no rule exists or rule is inactive
        /// </summary>
        private async Task<bool> ShouldSendEmailAsync(int documentTypeId, string triggerType)
        {
            var recipients = await GetEmailRecipientsAsync(documentTypeId, triggerType);
            return recipients.Any();
        }

        private static bool IsPublicUserSubmission(FORM_SUBMISSIONS submission)
        {
            return string.Equals(submission.SubmittedByUserId, "public-user", StringComparison.OrdinalIgnoreCase);
        }

        /// <summary>
        /// Ensures an ALERT_RULES entry exists for the given DocumentTypeId and TriggerType.
        /// Always creates a new rule with IsActive = false (حتى لو مفيش TargetUserId), عشان كل Event
        /// يبان في شاشة Alert Rules ويقدر المستخدم يفعّله أو يحدد له مستخدم / Role بعدين.
        /// </summary>
        private async Task EnsureAlertRuleExistsAsync(int documentTypeId, string triggerType, string? defaultUserId = null)
        {
            try
            {
                // المطلوب: كل حدث (Submission / Approval ...) يعمل Rule جديدة في ALERT_RULES
                // وتبقى Inactive لحد ما المستخدم يفعّلها من الشاشة.
                // لذلك لا نلمس أي Rules قديمة (سواء Active أو Inactive)، فقط نضيف صف جديد.
                // لو مفيش defaultUserId بنسيبه فاضي، والمستخدم من الشاشة يحدد TargetUser / TargetRole.
                var newRule = new ALERT_RULES
                {
                    DocumentTypeId = documentTypeId,
                    RuleName = !string.IsNullOrWhiteSpace(defaultUserId)
                        ? $"Auto-created: {triggerType} for {defaultUserId} (DocumentType {documentTypeId})"
                        : $"Auto-created: {triggerType} (DocumentType {documentTypeId})",
                    TriggerType = triggerType,
                    ConditionJson = "{}",
                    EmailTemplateId = null,
                    NotificationType = "Email",
                    TargetRoleId = string.Empty, // Changed from null to empty string (NOT NULL in DB)
                    TargetUserId = defaultUserId, // ممكن تكون null لو لسه محددناش مستخدم
                    IsActive = false, // Default to inactive - user must activate manually
                    IsDeleted = false,
                    CreatedDate = DateTime.UtcNow,
                    UpdatedDate = DateTime.UtcNow
                };

                _unitOfWork.AppDbContext.Set<ALERT_RULES>().Add(newRule);
                await _unitOfWork.CompleteAsyn();

                _logger?.LogInformation(
                    "Auto-created ALERT_RULES entry for DocumentTypeId {DocumentTypeId}, TriggerType {TriggerType}, TargetUserId {TargetUserId} (RuleId: {RuleId}, IsActive: false). User can activate it later.",
                    documentTypeId, triggerType, defaultUserId, newRule.Id);
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex,
                    "Error ensuring ALERT_RULES entry exists for DocumentTypeId {DocumentTypeId}, TriggerType {TriggerType}, TargetUserId {TargetUserId}. Exception: {ExceptionMessage}. InnerException: {InnerException}. Continuing without creating rule.",
                    documentTypeId, triggerType, defaultUserId, ex.Message, ex.InnerException?.Message ?? "None");
                // Don't throw - rule creation failure should not block the main workflow
                
                // Temporary: Also log to console for debugging
                Console.WriteLine($"[DEBUG] ALERT_RULES creation failed: {ex.Message}");
                if (ex.InnerException != null)
                {
                    Console.WriteLine($"[DEBUG] InnerException: {ex.InnerException.Message}");
                }
            }
        }

        private async Task CreateInternalNotificationsForApproversAsync(
            int documentTypeId,
            string triggerType,
            IEnumerable<string> defaultRecipients,
            int submissionId,
            CancellationToken cancellationToken)
        {
            try
            {
                // Only create notifications when ALERT_RULES says NotificationType = Internal or Both
                var rules = await _unitOfWork.AppDbContext.Set<ALERT_RULES>()
                    .AsNoTracking()
                    .Where(ar =>
                        ar.DocumentTypeId == documentTypeId &&
                        ar.TriggerType == triggerType &&
                        (ar.NotificationType == "Internal" || ar.NotificationType == "Both") &&
                        ar.IsActive &&
                        !ar.IsDeleted)
                    .ToListAsync(cancellationToken);

                if (!rules.Any())
                {
                    _logger?.LogInformation("No Internal/Both ALERT_RULE found for notifications. DocumentTypeId {DocumentTypeId}, TriggerType {TriggerType}",
                        documentTypeId, triggerType);
                    return;
                }

                // Resolve recipients from rules (TargetUserId / TargetRoleId). If not set, use defaults (approvers).
                var recipients = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

                foreach (var rule in rules)
                {
                    if (!string.IsNullOrWhiteSpace(rule.TargetUserId))
                    {
                        var userIds = rule.TargetUserId.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries)
                            .Select(x => x.Trim())
                            .Where(x => !string.IsNullOrWhiteSpace(x));
                        foreach (var u in userIds) recipients.Add(u);
                    }

                    if (!string.IsNullOrWhiteSpace(rule.TargetRoleId))
                    {
                        var roleIds = rule.TargetRoleId.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries)
                            .Select(x => x.Trim())
                            .Where(x => !string.IsNullOrWhiteSpace(x))
                            .ToList();

                        if (roleIds.Any())
                        {
                            var usersFromRoles = await ExecuteWithWorkflowRuntimeServiceAsync(
                                    runtime => runtime.ResolveUsersFromRolesAsync(roleIds))
                                ?? new List<string>();
                            foreach (var u in usersFromRoles.Where(x => !string.IsNullOrWhiteSpace(x)))
                                recipients.Add(u);
                        }
                    }
                }

                if (!recipients.Any())
                {
                    foreach (var u in defaultRecipients.Where(x => !string.IsNullOrWhiteSpace(x)))
                        recipients.Add(u);
                }

                if (!recipients.Any())
                {
                    _logger?.LogWarning("Internal notification rules exist but no recipients resolved for submission {SubmissionId}", submissionId);
                    return;
                }

                // Prevent duplicates: if notification already exists for the same (userId, referenceType, referenceId) and not deleted, skip.
                var refType = triggerType;
                var existing = await _unitOfWork.AppDbContext.Set<NOTIFICATIONS>()
                    .AsNoTracking()
                    .Where(n =>
                        !n.IsDeleted &&
                        n.ReferenceType == refType &&
                        n.ReferenceId == submissionId &&
                        recipients.Contains(n.UserId))
                    .Select(n => n.UserId)
                    .ToListAsync(cancellationToken);

                var existingSet = new HashSet<string>(existing, StringComparer.OrdinalIgnoreCase);
                var now = DateTime.UtcNow;

                var toCreate = recipients
                    .Where(u => !existingSet.Contains(u))
                    .Select(u => new NOTIFICATIONS
                    {
                        UserId = u,
                        Title = "New Submission Pending",
                        Message = "A new form has been submitted and requires your approval",
                        Type = "Info",
                        ReferenceType = refType,
                        ReferenceId = submissionId,
                        IsRead = false,
                        ReadAt = null,
                        CreatedDate = now,
                        UpdatedDate = now,
                        IsActive = true,
                        IsDeleted = false
                    })
                    .ToList();

                if (!toCreate.Any())
                {
                    _logger?.LogInformation("No new internal notifications to create for submission {SubmissionId}", submissionId);
                    return;
                }

                _unitOfWork.AppDbContext.Set<NOTIFICATIONS>().AddRange(toCreate);
                await _unitOfWork.CompleteAsyn();

                _logger?.LogInformation("Created {Count} internal notifications for submission {SubmissionId} (TriggerType {TriggerType})",
                    toCreate.Count, submissionId, triggerType);
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "Failed to create internal notifications for submission {SubmissionId}", submissionId);
            }
        }

        private Task CreateInternalNotificationsForTriggerAsync(
            int documentTypeId,
            string triggerType,
            IEnumerable<string> defaultRecipients,
            int submissionId,
            string title,
            string message,
            string severityType,
            CancellationToken cancellationToken)
        {
            // Reuse the existing recipient resolution logic.
            // We create NOTIFICATIONS with ReferenceType = triggerType, ReferenceId = submissionId.
            // Only created if ALERT_RULES.NotificationType is Internal/Both for this trigger.
            return CreateInternalNotificationsCoreAsync(
                documentTypeId,
                triggerType,
                defaultRecipients,
                submissionId,
                title,
                message,
                severityType,
                cancellationToken);
        }

        private async Task CreateInternalNotificationsCoreAsync(
            int documentTypeId,
            string triggerType,
            IEnumerable<string> defaultRecipients,
            int submissionId,
            string title,
            string message,
            string severityType,
            CancellationToken cancellationToken)
        {
            try
            {
                var rules = await _unitOfWork.AppDbContext.Set<ALERT_RULES>()
                    .AsNoTracking()
                    .Where(ar =>
                        ar.DocumentTypeId == documentTypeId &&
                        ar.TriggerType == triggerType &&
                        (ar.NotificationType == "Internal" || ar.NotificationType == "Both") &&
                        ar.IsActive &&
                        !ar.IsDeleted)
                    .ToListAsync(cancellationToken);

                if (!rules.Any())
                {
                    // For approval result events, create internal notifications even without explicit rules.
                    if (triggerType == "ApprovalApproved" || triggerType == "ApprovalRejected" || triggerType == "ApprovalReturned")
                    {
                        _logger?.LogInformation("No Internal/Both ALERT_RULE found for trigger {TriggerType} (DocumentTypeId {DocumentTypeId}). Using fallback recipients.",
                            triggerType, documentTypeId);
                    }
                    else
                {
                    _logger?.LogInformation("No Internal/Both ALERT_RULE found for trigger {TriggerType} (DocumentTypeId {DocumentTypeId})",
                        triggerType, documentTypeId);
                    return;
                    }
                }

                var recipients = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

                foreach (var rule in rules)
                {
                    if (!string.IsNullOrWhiteSpace(rule.TargetUserId))
                    {
                        var userIds = rule.TargetUserId.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries)
                            .Select(x => x.Trim())
                            .Where(x => !string.IsNullOrWhiteSpace(x));
                        foreach (var u in userIds) recipients.Add(u);
                    }

                    if (!string.IsNullOrWhiteSpace(rule.TargetRoleId))
                    {
                        var roleIds = rule.TargetRoleId.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries)
                            .Select(x => x.Trim())
                            .Where(x => !string.IsNullOrWhiteSpace(x))
                            .ToList();

                        if (roleIds.Any())
                        {
                            var usersFromRoles = await ExecuteWithWorkflowRuntimeServiceAsync(
                                    runtime => runtime.ResolveUsersFromRolesAsync(roleIds))
                                ?? new List<string>();
                            foreach (var u in usersFromRoles.Where(x => !string.IsNullOrWhiteSpace(x)))
                                recipients.Add(u);
                        }
                    }
                }

                if (!recipients.Any())
                {
                    foreach (var u in defaultRecipients.Where(x => !string.IsNullOrWhiteSpace(x)))
                        recipients.Add(u);
                }

                if (!recipients.Any())
                {
                    _logger?.LogWarning("Internal notification rules exist but no recipients resolved for trigger {TriggerType}, submission {SubmissionId}",
                        triggerType, submissionId);
                    return;
                }

                var existing = await _unitOfWork.AppDbContext.Set<NOTIFICATIONS>()
                    .AsNoTracking()
                    .Where(n =>
                        !n.IsDeleted &&
                        n.ReferenceType == triggerType &&
                        n.ReferenceId == submissionId &&
                        recipients.Contains(n.UserId))
                    .Select(n => n.UserId)
                    .ToListAsync(cancellationToken);

                var existingSet = new HashSet<string>(existing, StringComparer.OrdinalIgnoreCase);
                var now = DateTime.UtcNow;

                var toCreate = recipients
                    .Where(u => !existingSet.Contains(u))
                    .Select(u => new NOTIFICATIONS
                    {
                        UserId = u,
                        Title = title,
                        Message = message,
                        Type = severityType,
                        ReferenceType = triggerType,
                        ReferenceId = submissionId,
                        IsRead = false,
                        ReadAt = null,
                        CreatedDate = now,
                        UpdatedDate = now,
                        IsActive = true,
                        IsDeleted = false
                    })
                    .ToList();

                if (!toCreate.Any())
                {
                    _logger?.LogInformation("No new internal notifications to create for trigger {TriggerType}, submission {SubmissionId}",
                        triggerType, submissionId);
                    return;
                }

                _unitOfWork.AppDbContext.Set<NOTIFICATIONS>().AddRange(toCreate);
                await _unitOfWork.CompleteAsyn();

                _logger?.LogInformation("Created {Count} internal notifications for trigger {TriggerType}, submission {SubmissionId}",
                    toCreate.Count, triggerType, submissionId);
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "Failed to create internal notifications for trigger {TriggerType}, submission {SubmissionId}",
                    triggerType, submissionId);
            }
        }

        /// <summary>
        /// Execute CopyToDocument actions for a specific event
        /// </summary>
        private async Task ExecuteCopyToDocumentActionsAsync(int submissionId, string eventType, string? executedByUserId)
        {
            try
            {
                await using var scope = _scopeFactory.CreateAsyncScope();
                var executorService = scope.ServiceProvider.GetService<CopyToDocumentActionExecutorService>();
                if (executorService != null)
                {
                    await executorService.ExecuteCopyToDocumentActionsForEventAsync(submissionId, eventType, executedByUserId);
                }
                else
                {
                    _logger?.LogWarning("CopyToDocumentActionExecutorService not found in service provider");
                }
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "Error executing CopyToDocument actions for event {EventType}, submission {SubmissionId}",
                    eventType, submissionId);
                // Don't throw - action execution failures shouldn't break the main workflow
            }
        }
    }
}
